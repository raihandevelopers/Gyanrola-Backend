require("dotenv").config();

const Ebook = require("../models/Ebooks");
const Transaction = require("../models/Transaction");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const axios = require("axios");
const User = require("../models/User");
const {
  StandardCheckoutClient,
  Env,
  StandardCheckoutPayRequest,
} = require("pg-sdk-node");
const { Poppler } = require("node-poppler");
const poppler = new Poppler();
const { promises: fsPromises } = require("fs");

const CLIENT_ID = process.env.CLIENT_ID;
const CLIENT_SECRET = process.env.CLIENT_SECRET;
const CLIENT_VERSION = Number(process.env.CLIENT_VERSION);

const clientId = CLIENT_ID;
const clientSecret = CLIENT_SECRET;
const clientVersion = CLIENT_VERSION;
const env = Env.SANDBOX;

// console.log("Client ID:", CLIENT_ID);
// console.log("Client Secret:", CLIENT_SECRET);
// console.log("Client Version:", CLIENT_VERSION);

const client = StandardCheckoutClient.getInstance(
  clientId,
  clientSecret,
  clientVersion,
  env
);

const { randomUUID } = require("crypto");

const PHONEPE_MERCHANT_KEY = process.env.PHONEPE_MERCHANT_KEY;
const PHONEPE_SALT_INDEX = process.env.PHONEPE_SALT_INDEX;
const PHONEPE_BASE_URL = process.env.PHONEPE_BASE_URL;
const PHONEPE_MERCHANT_ID = process.env.PHONEPE_MERCHANT_ID;
const APP_BE_URL = process.env.APP_BE_URL;
const APP_FE_URL = process.env.APP_FE_URL;
const PHONEPE_ENVIRONMENT = process.env.PHONEPE_ENVIRONMENT;

// Function to extract the first page as an image
const extractFirstPageAsImage = async (pdfPath) => {
  // Ensure the directory exists
  const imageDir = path.join(process.cwd(), "uploads", "images");
  try {
    await fsPromises.mkdir(imageDir, { recursive: true });
  } catch (error) {
    console.error("Error creating directory:", error);
  }

  // Generate output filename based on PDF filename
  const pdfFilename = path.basename(pdfPath, ".pdf");
  const outputFile = path.join(imageDir, `${pdfFilename}.jpg`);

  // Create relative path for database storage
  const relativeImagePath = path.join(
    "uploads",
    "images",
    `${pdfFilename}.jpg`
  );

  // Convert options
  const options = {
    firstPageToConvert: 1,
    lastPageToConvert: 1,
    pngFile: true, // Specify PNG output
  };

  try {
    await poppler.pdfToCairo(pdfPath, outputFile, options);
    // pdf-poppler adds a page number suffix, so we need to rename
    const files = await fsPromises.readdir(imageDir);
    const generatedFile = files.find(
      (file) => file.startsWith(pdfFilename) && file.endsWith(".png")
    );

    if (generatedFile) {
      const fullGeneratedPath = path.join(imageDir, generatedFile);
      await fsPromises.rename(fullGeneratedPath, outputFile);
    } else {
      throw new Error("No image file generated by node-poppler");
    }

    // Return the relative path for storing in the database
    return relativeImagePath.replace(/\\/g, "/");
  } catch (error) {
    console.error("Error converting PDF to image:", error);
    throw error;
  }
};

// Upload new ebook
exports.uploadEbook = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No file uploaded or invalid file type",
      });
    }

    const { name, description, price, category } = req.body;
    if (!name || !description || !price || !category) {
      // Clean up uploaded file if validation fails
      if (req.file) {
        fs.unlinkSync(req.file.path);
      }
      return res.status(400).json({
        success: false,
        message: "Name, description, price, and category are required.",
      });
    }

    // Extract the first page as an image
    let imagePath;
    try {
      imagePath = await extractFirstPageAsImage(req.file.path);
    } catch (error) {
      fs.unlinkSync(req.file.path);
      return res.status(500).json({
        success: false,
        message: "Failed to process the PDF file",
        error: error.message,
      });
    }

    console.log(imagePath);

    const newEbook = new Ebook({
      name,
      description,
      price,
      category,
      filepath: req.file.path.replace(/\\/g, "/"), // Normalize file path for cross-platform compatibility
      imagePath: imagePath, // Store the relative path for the image
    });

    await newEbook.save();

    res.status(201).json({
      success: true,
      message: "Ebook uploaded successfully",
      data: newEbook,
    });
  } catch (error) {
    // Clean up uploaded file if error occurs
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get all ebooks
exports.getAllEbooks = async (req, res) => {
  try {
    const ebooks = await Ebook.find().select("-filepath").populate("category");

    res.status(200).json({
      success: true,
      count: ebooks.length,
      data: ebooks,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get single ebook
exports.getEbookById = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id)
      .select("-filepath")
      .populate("category");

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    res.status(200).json({
      success: true,
      data: ebook,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Update ebook
exports.updateEbook = async (req, res) => {
  try {
    const { name, description, price, category } = req.body;
    const updateData = { name, description, price, category };
    let oldFilePath = null;
    let oldImagePath = null;

    if (req.file) {
      // Get current file paths before updating
      const ebook = await Ebook.findById(req.params.id);
      if (!ebook) {
        fs.unlinkSync(req.file.path);
        return res.status(404).json({
          success: false,
          message: "Ebook not found",
        });
      }

      oldFilePath = ebook.filepath;
      oldImagePath = ebook.imagePath;

      // Add new file path to update data
      updateData.filepath = req.file.path.replace(/\\/g, "/");

      // Extract the first page as an image
      try {
        updateData.imagePath = await extractFirstPageAsImage(req.file.path);
      } catch (error) {
        fs.unlinkSync(req.file.path);
        return res.status(500).json({
          success: false,
          message: "Failed to process the PDF file",
          error: error.message,
        });
      }
    }

    const updatedEbook = await Ebook.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!updatedEbook) {
      if (req.file) {
        fs.unlinkSync(req.file.path);
        if (updateData.imagePath && fs.existsSync(updateData.imagePath)) {
          fs.unlinkSync(updateData.imagePath);
        }
      }
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    // Delete old files if new ones were uploaded
    if (req.file && oldFilePath) {
      fs.unlinkSync(oldFilePath);
      if (oldImagePath && fs.existsSync(path.join(process.cwd(), oldImagePath)))
        fs.unlinkSync(path.join(process.cwd(), oldImagePath));
    }

    res.status(200).json({
      success: true,
      message: "Ebook updated successfully",
      data: updatedEbook,
    });
  } catch (error) {
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Delete ebook
exports.deleteEbook = async (req, res) => {
  try {
    const ebook = await Ebook.findByIdAndDelete(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    // Delete the associated files
    const filePath = path.resolve(ebook.filepath);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }

    // Delete the image file if it exists
    const imagePath = path.resolve(path.join(process.cwd(), ebook.imagePath));
    if (fs.existsSync(imagePath)) {
      fs.unlinkSync(imagePath);
    }

    res.status(200).json({
      success: true,
      message: "Ebook deleted successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Download ebook file
exports.downloadEbook = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    const user = await User.findById(req.user.id);
    console.log(user);
    if (
      !user ||
      !(user?.purchases?.ebooks || []).some(
        (p) => p.ebookId.toString() === ebook._id.toString()
      )
    ) {
      return res.status(403).json({
        success: false,
        message: "You have not purchased this ebook.",
      });
    }

    const filePath = path.resolve(ebook.filepath); // Converts to OS-specific format
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        message: "File not found",
      });
    }

    res.download(filePath, `${ebook.name}.pdf`, (err) => {
      if (err) {
        console.error("Download error:", err);
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get ebook cover image
exports.getEbookCoverImage = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    const imagePath = path.join(process.cwd(), ebook.imagePath);
    if (!fs.existsSync(imagePath)) {
      return res.status(404).json({
        success: false,
        message: "Cover image not found",
      });
    }

    res.sendFile(imagePath);
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// // const PHONEPE_BASE_URL = "https://api-preprod.phonepe.com/apis/pg-sandbox"; // Updated to use the correct URL
// const PHONEPE_BASE_URL = "https://api.phonepe.com/apis/hermes";
// // const PRODUCTION_PHONEPE_BASE_URL = "https://api.phonepe.com/apis/hermes"; // Added production URL

// let PHONEPE_MERCHANT_ID = "UATSB123";
// let PHONEPE_MERCHANT_KEY = "69cd2942-0674-4b03-aeb2-8693818a4d2a";
// let PHONEPE_CALLBACK_URL = "your_callback_url";
// let PHONEPE_BASE_URL = "https://api-preprod.phonepe.com/apis/pg-sandbox";
// let PHONEPE_SALT_INDEX = 1;

// // PHONEPE_MERCHANT_ID = CLIENT_MID;
// // PHONEPE_MERCHANT_KEY = PHONEPE_MERCHANT_KEY;
console.log("Mercant key:", PHONEPE_MERCHANT_KEY);

const ENDPOINT = "/pg/v1/pay";

// test = "v2"; // Set to "v2" for testing
let expires_at = null; // Initialize token expiry variable
let access_token = null; // Initialize access token variable

// Create Ebook Order with PhonePe Integration
exports.createEbookOrder = async (req, res) => {
  const { ebookId } = req.body;
  const userId = req.user ? req.user.id : null;

  try {
    const ebook = await Ebook.findById(ebookId);
    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found.",
      });
    }

    const transaction = new Transaction({
      ebookId,
      userId: userId || null, // Null for guest users
      transactionId: `TXN_${Date.now()}`, // Generate a unique transaction ID
      amount: ebook.price * 100, // Convert to paise
    });

    await transaction.save();

    if (PHONEPE_ENVIRONMENT === "PROD") {
      try {
        const request = StandardCheckoutPayRequest.builder()
          .merchantOrderId(transaction.transactionId)
          .amount(transaction.amount)
          .redirectUrl(`${APP_BE_URL}/api/ebooks/verify/${transaction._id}`)
          .build();

        const response = await client.pay(request);
        const checkoutPageUrl = response?.redirectUrl;

        if (!checkoutPageUrl) {
          throw new Error("Failed to retrieve checkout page URL.");
        }

        return res.status(200).json({
          success: true,
          paymentUrl: checkoutPageUrl,
          transaction,
        });
      } catch (error) {
        console.error("Error during payment initiation:", error);
        return res.status(500).json({
          success: false,
          message: "Error initiating payment.",
          error: error.message,
        });
      }
    }
    // else if (test === "v2") {
    //   if (expires_at === null || expires_at * 1000 <= Date.now()) {
    //     const UAT_HOST_URL = "https://api-preprod.phonepe.com/apis/pg-sandbox";
    //     const PROD_HOST_URL = "https://api.phonepe.com/apis/identity-manager";
    //     const PHONE_PE_HOST_URL = PROD_HOST_URL; // Use UAT for testing
    //     const TOKEN_ENDPOINT = "/v1/oauth/token";
    //     const response = await axios.post(
    //       `${PHONE_PE_HOST_URL}${TOKEN_ENDPOINT}`,
    //       {
    //         client_id: CLIENT_ID,
    //         client_version: CLIENT_VERSION,
    //         client_secret: CLIENT_SECRET,
    //         grant_type: "client_credentials",
    //       },
    //       {
    //         headers: {
    //           "Content-Type": "application/x-www-form-urlencoded",
    //         },
    //       }
    //     );
    //     expires_at = response.data.expires_at; // Set the token expiry time
    //     access_token = response.data.access_token; // Store the access token
    //   }

    // }
    else {
      try {
        const payload = {
          merchantId: PHONEPE_MERCHANT_ID,
          merchantTransactionId: transaction.transactionId,
          merchantUserId: userId || "guest",
          amount: transaction.amount,
          redirectUrl: `${APP_BE_URL}/api/ebooks/verify/${transaction._id}`,
          redirectMode: "REDIRECT",
          paymentInstrument: {
            type: "PAY_PAGE",
          },
        };

        console.log("Payload:", payload);
        console.log("Payload String:", JSON.stringify(payload));
        const payloadString = JSON.stringify(payload);
        const checksumString =
          Buffer.from(payloadString).toString("base64") +
          "/pg/v1/pay" +
          PHONEPE_MERCHANT_KEY;
        console.log("Checksum String:", checksumString);
        const checksum =
          crypto.createHash("sha256").update(checksumString).digest("hex") +
          "###" +
          PHONEPE_SALT_INDEX; // Use the correct salt index
        console.log("Checksum:", checksum);

        const response = await axios.post(
          `${PHONEPE_BASE_URL}${ENDPOINT}`,
          { request: Buffer.from(payloadString).toString("base64") },
          {
            headers: {
              "Content-Type": "application/json",
              "X-VERIFY": checksum,
              accept: "application/json",
            },
          }
        );

        if (response.data.success) {
          res.status(200).json({
            success: true,
            paymentUrl: response.data.data.instrumentResponse.redirectInfo.url,
            transaction,
          });
        } else {
          throw new Error(
            response.data.message || "Payment initiation failed."
          );
        }
      } catch (error) {
        console.error("Error during payment initiation:", error.response);
        res.status(500).json({
          success: false,
          message: "Error initiating payment.",
          error: error.message,
        });
      }
    }
  } catch (error) {
    console.log(error);
    res.status(400).json({
      success: false,
      message: "Error creating transaction.",
      error,
    });
  }
};

// Verify Payment Status
exports.verifyPayment = async (req, res) => {
  const { id } = req.params;

  try {
    const transaction = await Transaction.findById(id);
    if (!transaction) {
      return res.status(404).json({
        success: false,
        message: "Transaction not found.",
      });
    }

    if (PHONEPE_ENVIRONMENT === "PROD") {
      const response = await client.getOrderStatus(transaction.transactionId);
      const state = response?.state;
      console.log("State:", state);
      if (state === "COMPLETED") {
        transaction.status = "Success";
        await transaction.save();
        const user = await User.findById(transaction.userId);
        if (user) {
          user.purchases.ebooks.push({
            ebookId: transaction.ebookId,
            transactionId: transaction.transactionId,
          });
          await user.save();
        }
        return res.redirect(`${APP_FE_URL}/?success=true`);
      } else {
        if (state === "FAILED") {
          transaction.status = "Failed";
          await transaction.save();
        }
        return res.redirect(`${APP_FE_URL}/?success=false`);
      }
    }
    // Non-production environment (e.g., sandbox)
    else {
      const statusUrl = `${PHONEPE_BASE_URL}/pg/v1/status/${PHONEPE_MERCHANT_ID}/${transaction.transactionId}`;
      const checksumString =
        `/pg/v1/status/${PHONEPE_MERCHANT_ID}/${transaction.transactionId}` +
        PHONEPE_MERCHANT_KEY;
      const checksum =
        crypto.createHash("sha256").update(checksumString).digest("hex") +
        "###" +
        PHONEPE_SALT_INDEX; // Use the correct salt index

      const response = await axios.get(statusUrl, {
        headers: {
          "Content-Type": "application/json",
          "X-VERIFY": checksum,
          accept: "application/json",
        },
      });

      if (response.data && response.data.code === "PAYMENT_SUCCESS") {
        transaction.status = "Success";
        await transaction.save();

        const user = await User.findById(transaction.userId);
        user.purchases.ebooks.push({
          ebookId: transaction.ebookId,
          transactionId: transaction.transactionId,
        });

        await user.save();
        res.redirect(`${APP_FE_URL}/?success=true`);
      } else {
        transaction.status = "Failed";
        await transaction.save();
        res.redirect(`${APP_FE_URL}/?success=false`);
      }
    }
  } catch (error) {
    console.error("Error verifying payment:", error);
    res.redirect(`${APP_FE_URL}/?success=false`);
  }
};

// const {
//   APP_BE_URL,
//   PHONEPE_MERCHANT_ID,
//   PHONEPE_MERCHANT_KEY,
//   PHONEPE_SALT_INDEX,
// } = process.env;

// const sha256 = (string) => {
//   return crypto.createHash("sha256").update(string).digest("hex");
// };
