const Ebook = require("../models/Ebooks");
const Transaction = require("../models/Transaction");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const axios = require("axios");
const User = require("../models/User");
const {
  StandardCheckoutClient,
  StandardCheckoutPayRequest,
} = require("pg-sdk-node");
const { Poppler } = require("node-poppler");
const poppler = new Poppler();
const { promises: fsPromises } = require("fs");
const {
  clientId,
  clientSecret,
  clientVersion,
  env,
  APP_BE_URL,
  APP_FE_URL,
} = require("./phonepe_credentials/credentials");

const client = StandardCheckoutClient.getInstance(
  clientId,
  clientSecret,
  clientVersion,
  env
);

const { randomUUID } = require("crypto");

// Function to extract the first page as an image
const extractFirstPageAsImage = async (pdfPath) => {
  // Ensure the directory exists
  const imageDir = path.join(process.cwd(), "uploads", "images");
  try {
    await fsPromises.mkdir(imageDir, { recursive: true });
  } catch (error) {
    console.error("Error creating directory:", error);
  }

  // Generate output filename based on PDF filename
  const pdfFilename = path.basename(pdfPath, ".pdf");
  const outputFile = path.join(imageDir, `${pdfFilename}.jpg`);

  // Create relative path for database storage
  const relativeImagePath = path.join(
    "uploads",
    "images",
    `${pdfFilename}.jpg`
  );

  // Convert options
  const options = {
    firstPageToConvert: 1,
    lastPageToConvert: 1,
    pngFile: true, // Specify PNG output
  };

  try {
    await poppler.pdfToCairo(pdfPath, outputFile, options);
    // pdf-poppler adds a page number suffix, so we need to rename
    const files = await fsPromises.readdir(imageDir);
    const generatedFile = files.find(
      (file) => file.startsWith(pdfFilename) && file.endsWith(".png")
    );

    if (generatedFile) {
      const fullGeneratedPath = path.join(imageDir, generatedFile);
      await fsPromises.rename(fullGeneratedPath, outputFile);
    } else {
      throw new Error("No image file generated by node-poppler");
    }

    // Return the relative path for storing in the database
    return relativeImagePath.replace(/\\/g, "/");
  } catch (error) {
    console.error("Error converting PDF to image:", error);
    throw error;
  }
};

// Upload new ebook
exports.uploadEbook = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No file uploaded or invalid file type",
      });
    }

    const { name, description, price, category } = req.body;
    if (!name || !description || !price || !category) {
      // Clean up uploaded file if validation fails
      if (req.file) {
        fs.unlinkSync(req.file.path);
      }
      return res.status(400).json({
        success: false,
        message: "Name, description, price, and category are required.",
      });
    }

    // Extract the first page as an image
    let imagePath;
    try {
      imagePath = await extractFirstPageAsImage(req.file.path);
    } catch (error) {
      fs.unlinkSync(req.file.path);
      return res.status(500).json({
        success: false,
        message: "Failed to process the PDF file",
        error: error.message,
      });
    }

    console.log(imagePath);

    const newEbook = new Ebook({
      name,
      description,
      price,
      category,
      filepath: req.file.path.replace(/\\/g, "/"), // Normalize file path for cross-platform compatibility
      imagePath: imagePath, // Store the relative path for the image
    });

    await newEbook.save();

    res.status(201).json({
      success: true,
      message: "Ebook uploaded successfully",
      data: newEbook,
    });
  } catch (error) {
    // Clean up uploaded file if error occurs
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get all ebooks
exports.getAllEbooks = async (req, res) => {
  try {
    const ebooks = await Ebook.find().select("-filepath").populate("category");

    res.status(200).json({
      success: true,
      count: ebooks.length,
      data: ebooks,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get single ebook
exports.getEbookById = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id)
      .select("-filepath")
      .populate("category");

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    res.status(200).json({
      success: true,
      data: ebook,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Update ebook
exports.updateEbook = async (req, res) => {
  try {
    const { name, description, price, category } = req.body;
    const updateData = { name, description, price, category };
    let oldFilePath = null;
    let oldImagePath = null;

    if (req.file) {
      // Get current file paths before updating
      const ebook = await Ebook.findById(req.params.id);
      if (!ebook) {
        fs.unlinkSync(req.file.path);
        return res.status(404).json({
          success: false,
          message: "Ebook not found",
        });
      }

      oldFilePath = ebook.filepath;
      oldImagePath = ebook.imagePath;

      // Add new file path to update data
      updateData.filepath = req.file.path.replace(/\\/g, "/");

      // Extract the first page as an image
      try {
        updateData.imagePath = await extractFirstPageAsImage(req.file.path);
      } catch (error) {
        fs.unlinkSync(req.file.path);
        return res.status(500).json({
          success: false,
          message: "Failed to process the PDF file",
          error: error.message,
        });
      }
    }

    const updatedEbook = await Ebook.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!updatedEbook) {
      if (req.file) {
        fs.unlinkSync(req.file.path);
        if (updateData.imagePath && fs.existsSync(updateData.imagePath)) {
          fs.unlinkSync(updateData.imagePath);
        }
      }
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    // Delete old files if new ones were uploaded
    if (req.file && oldFilePath) {
      fs.unlinkSync(oldFilePath);
      if (oldImagePath && fs.existsSync(path.join(process.cwd(), oldImagePath)))
        fs.unlinkSync(path.join(process.cwd(), oldImagePath));
    }

    res.status(200).json({
      success: true,
      message: "Ebook updated successfully",
      data: updatedEbook,
    });
  } catch (error) {
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Delete ebook
exports.deleteEbook = async (req, res) => {
  try {
    const ebook = await Ebook.findByIdAndDelete(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    // Delete the associated files
    const filePath = path.resolve(ebook.filepath);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }

    // Delete the image file if it exists
    const imagePath = path.resolve(path.join(process.cwd(), ebook.imagePath));
    if (fs.existsSync(imagePath)) {
      fs.unlinkSync(imagePath);
    }

    res.status(200).json({
      success: true,
      message: "Ebook deleted successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Download ebook file
exports.downloadEbook = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    const user = await User.findById(req.user.id);
    console.log(user);
    if (
      !user ||
      !(user?.purchases?.ebooks || []).some(
        (p) => p.ebookId.toString() === ebook._id.toString()
      )
    ) {
      return res.status(403).json({
        success: false,
        message: "You have not purchased this ebook.",
      });
    }

    const filePath = path.resolve(ebook.filepath); // Converts to OS-specific format
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        message: "File not found",
      });
    }

    res.download(filePath, `${ebook.name}.pdf`, (err) => {
      if (err) {
        console.error("Download error:", err);
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get ebook cover image
exports.getEbookCoverImage = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    const imagePath = path.join(process.cwd(), ebook.imagePath);
    if (!fs.existsSync(imagePath)) {
      return res.status(404).json({
        success: false,
        message: "Cover image not found",
      });
    }

    res.sendFile(imagePath);
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Create Ebook Order with PhonePe Integration
exports.createEbookOrder = async (req, res) => {
  const { ebookId } = req.body;
  const userId = req.user ? req.user.id : null;

  try {
    const ebook = await Ebook.findById(ebookId);
    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found.",
      });
    }

    const transaction = new Transaction({
      ebookId,
      userId: userId, // Null for guest users
      transactionId: `TXN_${Date.now()}`, // Generate a unique transaction ID
      amount: (ebook.price && ebook.price > 1 ? ebook.price : 1) * 100, // Convert to paise (setting ebook price to rs 1, in case of price < 1)
    });

    await transaction.save();

    try {
      const request = StandardCheckoutPayRequest.builder()
        .merchantOrderId(transaction.transactionId)
        .amount(transaction.amount)
        .redirectUrl(`${APP_BE_URL}/api/ebooks/verify/${transaction._id}`)
        .build();

      const response = await client.pay(request);
      const checkoutPageUrl = response?.redirectUrl;

      if (!checkoutPageUrl) {
        throw new Error("Failed to retrieve checkout page URL.");
      }

      return res
        .setHeader("Referrer-Policy", "origin-when-cross-origin")
        .status(200)
        .json({
          success: true,
          paymentUrl: checkoutPageUrl,
          transaction,
        });
    } catch (error) {
      console.error("Error during payment initiation:", error);
      return res.status(500).json({
        success: false,
        message: "Error initiating payment.",
        error: error.message,
      });
    }
  } catch (error) {
    console.log(error);
    res.status(400).json({
      success: false,
      message: "Error creating transaction.",
      error,
    });
  }
};

// Verify Payment Status
exports.verifyPayment = async (req, res) => {
  const { id } = req.params;

  try {
    const transaction = await Transaction.findById(id);
    if (!transaction) {
      return res.status(404).json({
        success: false,
        message: "Transaction not found.",
      });
    }
    const response = await client.getOrderStatus(transaction.transactionId);
    const state = response?.state;
    console.log("State:", state);
    if (state === "COMPLETED") {
      transaction.status = "Success";
      await transaction.save();
      const user = await User.findById(transaction.userId);
      if (user) {
        user.purchases.ebooks.push({
          ebookId: transaction.ebookId,
          transactionId: transaction.transactionId,
        });
        await user.save();
      }
      return res.redirect(`${APP_FE_URL}/?success=true`);
    } else {
      if (state === "FAILED") {
        transaction.status = "Failed";
        await transaction.save();
      }
      return res.redirect(`${APP_FE_URL}/?success=false`);
    }
  } catch (error) {
    console.error("Error verifying payment:", error);
    res.redirect(`${APP_FE_URL}/?success=false`);
  }
};
