const Ebook = require("../models/Ebooks");
const fs = require("fs");
const path = require("path");
const { convert } = require("pdf-poppler");
const { promises: fsPromises } = require("fs");

// Function to extract the first page as an image
const extractFirstPageAsImage = async (pdfPath) => {
  // Ensure the directory exists
  const imageDir = path.join(process.cwd(), "uploads", "images");
  try {
    await fsPromises.mkdir(imageDir, { recursive: true });
  } catch (error) {
    console.error("Error creating directory:", error);
  }

  // Generate output filename based on PDF filename
  const pdfFilename = path.basename(pdfPath, ".pdf");
  const outputFile = path.join(imageDir, `${pdfFilename}.jpg`);

  // Create relative path for database storage
  const relativeImagePath = path.join(
    "uploads",
    "images",
    `${pdfFilename}.jpg`
  );

  // Convert options
  const options = {
    format: "jpeg",
    out_dir: imageDir,
    out_prefix: pdfFilename,
    page: 1,
    scale: 1024, // Higher resolution
  };

  try {
    await convert(pdfPath, options);
    // pdf-poppler adds a page number suffix, so we need to rename
    const files = await fsPromises.readdir(imageDir);
    const generatedFile = files.find(
      (file) => file.startsWith(pdfFilename) && file.endsWith(".jpg")
    );

    if (generatedFile) {
      const fullGeneratedPath = path.join(imageDir, generatedFile);
      await fsPromises.rename(fullGeneratedPath, outputFile);
    } else {
      throw new Error("No image file generated by pdf-poppler");
    }

    // Return the relative path for storing in the database
    return relativeImagePath.replace(/\\/g, "/");
  } catch (error) {
    console.error("Error converting PDF to image:", error);
    throw error;
  }
};

// Upload new ebook
exports.uploadEbook = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No file uploaded or invalid file type",
      });
    }

    const { name, description, price, category } = req.body;
    if (!name || !description || !price || !category) {
      // Clean up uploaded file if validation fails
      if (req.file) {
        fs.unlinkSync(req.file.path);
      }
      return res.status(400).json({
        success: false,
        message: "Name, description, price, and category are required.",
      });
    }

    // Extract the first page as an image
    let imagePath;
    try {
      imagePath = await extractFirstPageAsImage(req.file.path);
    } catch (error) {
      fs.unlinkSync(req.file.path);
      return res.status(500).json({
        success: false,
        message: "Failed to process the PDF file",
        error: error.message,
      });
    }

    console.log(imagePath);

    const newEbook = new Ebook({
      name,
      description,
      price,
      category,
      filepath: req.file.path.replace(/\\/g, "/"), // Normalize file path for cross-platform compatibility
      imagePath: imagePath,
    });

    await newEbook.save();

    res.status(201).json({
      success: true,
      message: "Ebook uploaded successfully",
      data: newEbook,
    });
  } catch (error) {
    // Clean up uploaded file if error occurs
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get all ebooks
exports.getAllEbooks = async (req, res) => {
  try {
    const ebooks = await Ebook.find().select("-filepath").populate("category");

    res.status(200).json({
      success: true,
      count: ebooks.length,
      data: ebooks,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get single ebook
exports.getEbookById = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id)
      .select("-filepath")
      .populate("category");

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    res.status(200).json({
      success: true,
      data: ebook,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Update ebook
exports.updateEbook = async (req, res) => {
  try {
    const { name, description, price, category } = req.body;
    const updateData = { name, description, price, category };
    let oldFilePath = null;
    let oldImagePath = null;

    if (req.file) {
      // Get current file paths before updating
      const ebook = await Ebook.findById(req.params.id);
      if (!ebook) {
        fs.unlinkSync(req.file.path);
        return res.status(404).json({
          success: false,
          message: "Ebook not found",
        });
      }

      oldFilePath = ebook.filepath;
      oldImagePath = ebook.imagePath;

      // Add new file path to update data
      updateData.filepath = req.file.path.replace(/\\/g, "/");

      // Extract the first page as an image
      try {
        updateData.imagePath = await extractFirstPageAsImage(req.file.path);
      } catch (error) {
        fs.unlinkSync(req.file.path);
        return res.status(500).json({
          success: false,
          message: "Failed to process the PDF file",
          error: error.message,
        });
      }
    }

    const updatedEbook = await Ebook.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!updatedEbook) {
      if (req.file) {
        fs.unlinkSync(req.file.path);
        // Also delete the generated image if it exists
        if (updateData.imagePath && fs.existsSync(updateData.imagePath)) {
          fs.unlinkSync(updateData.imagePath);
        }
      }
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    // Delete old files if new ones were uploaded
    if (req.file && oldFilePath) {
      if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
      if (oldImagePath && fs.existsSync(path.join(process.cwd(), oldImagePath)))
        fs.unlinkSync(path.join(process.cwd(), oldImagePath));
    }

    res.status(200).json({
      success: true,
      message: "Ebook updated successfully",
      data: updatedEbook,
    });
  } catch (error) {
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Delete ebook
exports.deleteEbook = async (req, res) => {
  try {
    const ebook = await Ebook.findByIdAndDelete(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    // Delete the associated files
    const filePath = path.resolve(ebook.filepath);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }

    // Delete the image file if it exists
    const imagePath = path.resolve(path.join(process.cwd(), ebook.imagePath));
    if (fs.existsSync(imagePath)) {
      fs.unlinkSync(imagePath);
    }

    res.status(200).json({
      success: true,
      message: "Ebook deleted successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Download ebook file
exports.downloadEbook = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    const filePath = path.resolve(ebook.filepath); // Converts to OS-specific format
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        message: "File not found",
      });
    }

    res.download(filePath, `${ebook.name}.pdf`, (err) => {
      if (err) {
        console.error("Download error:", err);
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// Get ebook cover image
exports.getEbookCoverImage = async (req, res) => {
  try {
    const ebook = await Ebook.findById(req.params.id);

    if (!ebook) {
      return res.status(404).json({
        success: false,
        message: "Ebook not found",
      });
    }

    console.log(ebook.imagePath);

    const imagePath = path.join(process.cwd(), ebook.imagePath);
    if (!fs.existsSync(imagePath)) {
      return res.status(404).json({
        success: false,
        message: "Cover image not found",
      });
    }

    res.sendFile(imagePath);
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};
